# 使用变量与环境变量

- [使用变量与环境变量](#%e4%bd%bf%e7%94%a8%e5%8f%98%e9%87%8f%e4%b8%8e%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f)
  - [变量](#%e5%8f%98%e9%87%8f)
  - [变量使用拓展](#%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8%e6%8b%93%e5%b1%95)
  - [使用函数添加环境变量](#%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e6%b7%bb%e5%8a%a0%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f)
  - [使用 shell 进行数学运行](#%e4%bd%bf%e7%94%a8-shell-%e8%bf%9b%e8%a1%8c%e6%95%b0%e5%ad%a6%e8%bf%90%e8%a1%8c)
    - [bc——用于数学计算的高级使用工具](#bc%e7%94%a8%e4%ba%8e%e6%95%b0%e5%ad%a6%e8%ae%a1%e7%ae%97%e7%9a%84%e9%ab%98%e7%ba%a7%e4%bd%bf%e7%94%a8%e5%b7%a5%e5%85%b7)
  - [文件描述符与重定向](#%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6%e4%b8%8e%e9%87%8d%e5%ae%9a%e5%90%91)
    - [使用管道'|'重定向数据作为后续命令的 stdin](#%e4%bd%bf%e7%94%a8%e7%ae%a1%e9%81%93%e9%87%8d%e5%ae%9a%e5%90%91%e6%95%b0%e6%8d%ae%e4%bd%9c%e4%b8%ba%e5%90%8e%e7%bb%ad%e5%91%bd%e4%bb%a4%e7%9a%84-stdin)
    - [自定义文件描述符](#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%96%87%e4%bb%b6%e6%8f%8f%e8%bf%b0%e7%ac%a6)

## 变量

变量名由一系列字母、数字和下划线组成，其中不包含空白字符。常用惯例：`大写字母命名环境变量，使用驼峰命名法或小写字母命名其他变量`

- 使用`env`或`printenv`查看当前 shell 所定义的全部环境变量

  ```sh
  $ env
  PWD=...
  HOME=...
  SHELL=...

  # 查看其他进程的环境变量
  $ cat /proc/$PID/environ
  ```

- 使用等号操作符为变量赋值

  ```sh
  # 如果value不包含任何空白字符(例如空格), 那么久不需要将其放入引号中。
  varName=value
  ```

<img src="../attention.png" alt="attention" width=35 height=35/>注意，`var = value`不同于`var=value`。`两边没有空格的等号是赋值操作`，`加上空格的等号表示的是等量关系测试`

- 在变量名之前加上美元符号(`$`)就可以访问变量的内容

```sh
$ var ="value" # 将value赋值给变量var
$ echo $var

# 也可以写成
$ echo $(var)
```

- 在 printf、echo 或其他命令的`双引号`中引用变量值

```sh
$ fruit=apple
$ count=5
$ echo "We have $count ${fruit}s"
```

- export 命令

export 命令用于将 shell 变量输出为环境变量，或者将 shell 函数输出为环境变量。一个变量创建时，它不会自动地为在它之后创建的 shell 进程所知。而命令 export 可以向后面的 shell 传递变量的值。当一个 shell 脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export 命令可以用于传递一个或多个变量的值到任何后继脚本。

```txt
-f：代表[变量名称]中为函数名称；
-n：删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中；
-p：列出所有的 shell 赋予程序的环境变量。
```

```sh
$ HTTP_PROXY=192.168.1.23:3128
$ export HTTP_PROXY
```

PATH 变量列出一系列可供 shell 搜索特定应用程序的目录

```sh
$ echo $PATH
/home/slynux/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games

# 在path中添加一条新路径
$ export PATH="$PATH:/home/user/bin"
```

各目录路径之间以`:`分隔。\$PATH 通常定义在`/etc/environment`、`/etc/profile`或`~/.bashrc`

其他常用环境变量：`HOME`，`PWD`、`USER`、`UID`、`SHELL`等

<img src="../attention.png" alt="attention" width=35 height=35/>

1. 使用`单引号`，变量不会被扩展，仍依照原样显示。`$echo '$var'`会显示`$var`
2. 如果`$var`已经定义，那么`$var`会显示出该变量的值，如果没有被定义过，则什么都不显示

## 变量使用拓展

- 获取字符串长度：`length=${#var}`

```sh
$ var=12345678901234567890
$ echo ${#var}
20
```

- 识别当前所使用的 shell：`echo $SHELL`或者`echo $0`
- 检查是否为超级用户：

```sh
if [ $UID -ne 0 ]; then
  echo Non root user. Please run as root.
else
  echo Root user
fi
```

**注意：**`[`实际上是一个命令，必须将其与剩余的字符串用**空格**隔开，也可以写成如下格式

```sh
if test $UID -ne 0:1; then
  echo Non root user. Please run as root.
else
  echo Root user
fi
```

- 修改 Bash 的提示字符串(username@hostname:~\$)
  当打开终端或是运行 shell 时，会看到类似于`user@hostname:/home/$`的提示字符串，我们可以利用`PS1`环境变量来定义提示字符串。默认的提示字符串是在文件`~/.bashrc`中的某一行设置

  - 查看设置变量`PS1`的那一行

  ```sh
  $ cat ~/.bashrc | grep PS1
  PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
  ```

  - 修改提示字符串

  ```sh
  $ PS1='xxx'
  ```

- 可以利用类似于\e[1;31 的特定转义序列来设置彩色的提示字符串

## 使用函数添加环境变量

环境变量通常保存用于搜索可执行文件、库文件等的路径列表。例如`$PATH`和`$LD_LIBRARY_PATH`

- eval 会对后面的 cmdLine 进行两遍扫描，如果第一遍扫描后，cmdLine 是个普通命令，则执行此命令；如果 cmdLine 中含有变量的间接引用，则保证间接引用的语义。

```sh
# shell第1次扫描命令行时，它替换出pipe的值｜，接着eval使它再次扫描命令行，这时shell把｜作为管道符号了。
pipe="|"
eval ls $pipe wc -l
```

```sh
prepend() {
  [ -d "$2" ] && eval $1=\"$2\$\{$1:+':'\$$1\}\" && export $1 ;
}
```

## 使用 shell 进行数学运行

```sh
# 可以像为变量分配字符串值那样为其分配数值。
no1=4
no2=5

# let命令可以直接执行基本的算术操作。当使用let时，变量名之前不需要再添加$
let result=no1+no2
echo $result

# let命令其他操作
# 自加自减
let no1++
let no1--
let no+=6
let no-=6

# 其他方法

# 操作符[]的使用方法和let命令一样
result=$[ no1 + no2 ]
# 在[]也可以使用$前缀
result=$[ $no1 + 5 ]

# 也可以使用操作符(())，在(())中的变量名之前也要加上$
result=$(( no1 + 50 ))

# expr同样可以用于基本算术操作
result=`expr 3 + 4`
result=$(expr $no1 + 5)

# 以上方法不支持浮点数，只能用于整数运算。
```

### bc——用于数学计算的高级使用工具

```sh
$ echo "4 * 0.56" | bc
2.24

$ no=54;
$ result=`echo "$no * 1.5" | bc`
$ echo $result
81.0
```

`bc`可以接受操作控制前缀。这些前缀之间使用`分号`分隔

- 设定小数精度

```sh
# 参数scale=2将小数位个数设置为2
$ echo "scale=2;22/7" | bc
```

- 进制转换

```sh
# 十进制->二进制
$ no=100
$ echo "obase=2;$no" | bc
1100100

$ no=1100100
$ echo "obase=10;$no" | bc
100
```

- 计算平方以及平方根

```sh
$ echo "sqrt(100)" | bc # square root
$ echo "10^10" | bc #Square
```

## 文件描述符与重定向

`文件描述符`是与输入和输出流相关联的整数。例如，标准输入`stdin`，标准输出`stdout`，标准错误`stderr`，我们可以将某个文件描述符的内容重定向到另一个文件描述符中。script 可以使用大于号(>)将输出重定向到文件。文件描述符 0、1 和 2 是系统预留的。

- 0 —— stdin
- 1 —— stdout
- 2 —— stderr

```sh
# 使用>将文本保存到文件中,如果文件已经存在，会清空该文件中先前的内容
$ echo "This is a simple text 1" > temp.txt

# 使用>>将文本追加到文件中
$ ehco "This is a simple text 2" >> temp.txt

# 使用cat查看文件
cat temp.ext
```

<img src="../tips.png" alt="attention" width=30 height=30/>成功与不成功的命令

当命令发送错误并退回时，它会返回一个`非0`的的退出状态；当命令成功完成后，它会返回`为0`的退出状态。退出状态可以从特殊变量`$?`中获得（在命令结束后立刻运行`echo $?`，就可以打印退出状态）。

```sh
$ ls + > out.txt

# 重定向stderr
$ ls + 2> out.txt

# 重定向stderr和stdout
$ {cmd} 2>stderr.txt 1>stdout.txt

# 将stderr转换为stdout
$ {cmd} 2>&1 alloutput.txt
# 或者
$ {cmd} &> output.txt

# 如果不需要相应的输出，可以重定向到/dev/null
$ {cmd} 2>/dev/null

# 文件重定向到命令
$ {cmd} < file
```

### 使用管道'|'重定向数据作为后续命令的 stdin

`tee`命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的 stdin。存在缓存机制，每 1024 个字节将输出一次。若从管道接收输入数据，应该是缓冲区满，才将数据转存到指定的文件中。若文件内容不到 1024 个字节，则接收完从标准输入设备读入的数据后，将刷新一次缓冲区，并转存数据到指定文件。
<img src="../images/tee.gif" alt="attention" width=300 height=200/>

```sh
command | tee FILE1 FILE2 | otherCommand
```

### 自定义文件描述符

```sh
# 创建一个用于读取文件的文件描述符
$ echo this is a text line > input.txt
$ exec 3<input.txt #使用文件描述符3打开并读取文件

# 现在可以在命令中使用文件描述符3
$ cat <&3
this is a test line

# 如果要再次读取，需要用exec重新创建一个新的文件描述符，而不能继续使用文件描述符3了
$ exec 4>output.txt #打开文件进行写入
$ echo newline >&4
$ cat output.txt
newline

# 追加写入
$ exec 5>>input.txt
$ echo appended line >&5
$ cat input.txt
newline
appended line
```